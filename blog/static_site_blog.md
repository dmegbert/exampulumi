# Deploying a Production Grade Static Site on AWS using Route53, CloudFront, and S3 with Pulumi Infrastructure as Code (IaC)

![A red hard hat sitting on concrete with a blurry construction site in the background.](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/hardHat.png "Hard hat")

The following blog will walk you through setting up a secure static in AWS while using Pulumi
to provision and configure all the required infrastructure and deploy the static site files.

## Prerequisites
- An AWS account where you have full permissions
- A Pulumi account
- Basic to intermediate knowledge of AWS
- Understand how to use create react app or something similar (or a willingness to google it)

_If you have never used Pulumi, this will be a nice way to try it out and compare it to other
IaC tools like Terraform and AWS CDK._

## What we are building
- A static site that is a simple React/TypeScript application using React Router for a
client-side routing
- DNS management through Route53 and ACM (AWS Certificate Manager)
- An AWS CloudFront distribution for our CDN solution
- An S3 bucket to store our static site files and another one to store our 
log files from CloudFront

## Code and Site
- The code that accompanies this blog can be found on GitHub:
https://github.com/dmegbert/exampulumi
- The site is live and can be found at: https://exampulumi.com/ It is a very minimal site.
- Pulumi provides a number of example stacks. I used their static site as a starting point
and there are many lines of code that remain from that project. It is here:
https://github.com/pulumi/examples/tree/master/aws-py-static-website

## Project Setup
_I use a Mac and all of the example code and terminal commands are assuming the use of a Mac.
So non-mac users will need to adjust, at times. Also, I am using the Python implementation
of Pulumi._

1. If you have not done so, create a pair of AWS credentials for your local machine in IAM and
add them to your .zshrc or .bashrc or equivalent:  
`export AWS_ACCESS_KEY_ID=<YOUR_ACCESS_KEY_ID`  
`export AWS_SECRET_ACCESS_KEY=<YOUR_SECRET_ACCESS_KEY>`
 
2. If you have not previously installed Pulumi, open a terminal window and install it via homebrew:  
`brew install pulumi/tap/pulumi`
3. Create a new directory for this project. It will be the parent directory and will hold a subdirectory
created by Pulumi and another one generated by Create React App. `mkdir <YOUR_PROJECT_NAME>` for my project,
it is `exampulumi`
4. Change directory so you are inside the parent project directory:  
`cd exampulumi`
5. Now you are going to initiate a pulumi stack and validate that you are set up properly
6. Make a directory for your infrastructure code and cd into it:  
`mkdir <infra_dir_name>` I used infra  
`cd infra`  
`pulumi new aws-python`
7. You might be prompted to log into Pulumi if you've never logged in before. Then you'll be prompted
to set up the project. Feel free to use the defaults or update. I would recommend updating the project
name to the domain name that you will be using or something similarly descriptive and project-level as
we will use it to populate configuration values and a generic name like "infra" will not be helpful if
you end up deploying many resources to this AWS account.  
`project name: (infra) exampulumi`  
`project description: (A minimal AWS Pulumi program)`  
`Created project 'infra'`  
We will create a dev stack and a prod stack. For now, let's stick with dev, the default, and hit enter
to accept it. I've created this project in my personal pului account. If you are using an organization
account, then you should enter the stack as <org>/<stack>.  
`Please enter your desired stack name.`  
`Created stack 'dev'`  
And finally, enter your default AWS region. I will be using us-east-2. This will also create a virtual
environment and install the python packages needed for pulumi.  
`aws:region: The AWS region to deploy into: (us-east-1) us-east-2`  
`Saved config`  
`Installing dependencies...`  
All together, it should look like the following:
```shell
➜  exampulumi git:(main) ✗ cd infra
➜  infra git:(main) ✗ pulumi new aws-python
This command will walk you through creating a new Pulumi project.

Enter a value or leave blank to accept the (default), and press <ENTER>.
Press ^C at any time to quit.

project name: (infra) exampulumi
project description: (A minimal AWS Python Pulumi program)
Created project 'exampulumi'

Please enter your desired stack name.
To create a stack in an organization, use the format <org-name>/<stack-name> (e.g. `acmecorp/dev`).
stack name: (dev)
Created stack 'dev'

aws:region: The AWS region to deploy into: (us-east-1) us-east-2
Saved config

Installing dependencies...

Creating virtual environment...
Finished creating virtual environment
Updating pip, setuptools, and wheel in virtual environment...
...
<Packages getting installed -- very exciting log statements...>
...
Finished installing dependencies

Your new project is ready to go! ✨

To perform an initial deployment, run `pulumi up`
```
Now let's watch the magic happen! pulumi up in your terminal. It should show that a stack and a bucket
will be created. Click up to select yes and you'll see another screen that will show the stack and
bucket being created. Go to your AWS console and go to S3 and verify the bucket was created. You
have now deployed a bucket using Pulumi--Yay!!

## Project Structure and Configuration
At this point you have a minimal pulumi project. If you look at the files created in the prior
section you should see something equivalent to the following:
```shell
➜  exampulumi git:(main) ✗ tree  -L 2
.
└── infra
    ├── Pulumi.dev.yaml
    ├── Pulumi.yaml
    ├── __main__.py
    ├── requirements.txt
    └── venv
```
The `Pulumi.yaml` file contains project level configuration data and the `Pulumi.dev.yaml` file contains stack
level configuration data. Using these files in conjunction with some common naming patterns and a `config.py`
file enable you to organize configuration according the best practices as outlined in the [Twelve Factor
App's config section](https://12factor.net/config) that advocates a separation of config from code. Doing so
will enable you to easily deploy to multiple environments and re-use nearly all of this code for new projects
that require similar infrastructure.  

Open up your Pulumi.dev.yaml file and note the structure:
```yaml
config:
  aws:region: us-east-2
```

In your terminal, run a pulumi config command to add the environment variable for the environment (I know…)
`pulumi config set env dev` The file should update and now have that key / value pair.

```yaml
config:
  aws:region: us-east-2
  exampulumi:env: dev
```
A really nice feature of Pulumi's config command is the ability to encrypt sensitive environment information.
Depending on your security thresholds, you can simply encrypt values like API keys to 3rd party tools and
just commit them to version control along with the rest of your configuration files and code by adding the
`--secret` flag. Try it out: `pulumi config set top-secret-api-key IamSuperSecret`
```yaml
config:
  aws:region: us-east-2
  exampulumi:env: dev
  exampulumi:top-secret-api-key:
    secure: AAABAJKQ/APMiQjARYHziXlsSz2IYVRsYqFKiIfMqc+JpXcP1AQgrvijGj+8DA==
```
Get rid of that by running Pulumi config rm top-secret-api-key.  

Let's put that new configuration key/value pair to work. Create a new file creatively titled `config.py` at
the same level as the `__main__.py` file and the yaml files. In it add the following:
```python
import pulumi

config = pulumi.Config()

# Project
env = config.require("env")
service_name = pulumi.get_project()
prefix = f"{env}-{service_name}"
domain_name = f"{service_name}.com" # Or whatever domain name you are going to use
region = "us-east-2"
PROD = "prod"
DEV = "dev"

# UI
static_site_path = "../ui/build"
```
We'll use these values to maintain consistent naming patterns and differentiate resources that are "dev" and
"prod" for our two stack project.  

The other files created by pulumi include the `requirements.txt` file with the two Pulumi packages,
a `.gitignore` file, and a virtual environment folder: `venv`. The last file is the `__main__.py` file.
Open it up and you can see that one simple line of code is all it took to create a bucket. We will come
back to this file later. For now, just remove the boilerplate code but leave the exports section and
add the service name from the config.
```python
import pulumi

from config import service_name

# Add your exports here
pulumi.export('service name', service_name)
```

You can run `pulumi preview` and validate that the configuration is working.
```shell
(venv) ➜  infra git:(main) ✗ pulumi preview
Previewing update (dev)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER_NAME>/exampulumi/dev/previews/<UUID>

     Type                 Name            Plan
     pulumi:pulumi:Stack  exampulumi-dev

Outputs:
  + service name  : "exampulumi"
```
Create a resources directory and make it a python package with an `__init__.py` file and have it at
the same level as the `__main__.py` file. Within that package add the following `.py` files: `acm.py`,
`cloud_front.py`, `route_53.py`, `s3.py`. I like to have each AWS Service contained in a separate python
file. There's no magic to how I have it set up so feel free to deviate to a different structure that
works better for you. Now you should have the following directory structure. And there's times when 
I bend my own rules, as you'll see with the `cloud_front.py` file.
```shell
.
└── infra
    ├── Pulumi.dev.yaml
    ├── Pulumi.yaml
    ├── __main__.py
    ├── config.py
    ├── requirements.txt
    ├── resources
    │   ├── __init__.py
    │   ├── acm.py
    │   ├── cloud_front.py
    │   ├── route_53.py
    │   └── s3.py
    └── venv
        ├── bin
        ├── include
        ├── lib
        └── pyvenv.cfg
```
## Domain Name Registration
I have attempted to create all the resources for the static site solely through Pulumi and not create
anything via "ClickOps" (clicking around in the AWS console UI to manage infrastructure). However, it
appears to be impossible to register a new domain name via Route53 using Pulumi.

> The aws.route53domains.RegisteredDomain resource behaves differently from normal resources in that if
> a domain has been registered, the provider does not register this domain, but instead "adopts" it
> into management. A destroy does not delete the domain but does remove the resource from state.
> 
> -- [Pulumi Documentation](https://www.pulumi.com/registry/packages/aws/api-docs/route53domains/registereddomain/)

So, dear reader, on to the dreaded AWS console for some screen shot-guided clicking!  

Log in to AWS and go to Route53. The second section has a form field where you can search to see if
your domain name is available.  

![The form field in AWS where you enter your desired domain name to see if it is available.](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/domainRegistration.png "Domain Registration")  

If it is available, go ahead and complete the purchase. It will take a few minutes before the domain
name is fully registered and eventually you'll see something like the following for your domain name.

![Registered domain is shown to be ready](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/domainReady.png "Domain Registration is Ready")

Now we are ready to provision and configure the rest of the resources through Pulumi and beautiful Python code!

## Route53 and SSL Certificate through ACM
So far we have only set up a single stack, `dev`, for our project. There are times where we need to
configure our infrastructure differently depending upon what environment we are using. And certain
resources make sense to just live in one environment and be shared in the other environments. The
first place this occurs for a static site is in Route53. The top-level domain name you registered
will be a shared resource across stacks. For me it is exampulumi.com. And then we can use
subdomains for lower environments - dev.exampulumi.com, etc.  

To create your production stack, in your infra directory run:
`pulumi stack init prod` That will create a new stack. To manage its configuration, copy the
`Pulumi.dev.yaml` file into a new file named `Pulumi.prod.yaml` and edit that newly created
file so that the `env` key's value is changed to `prod`.

```yaml
config:
  aws:region: us-east-2
  exampulumi:env: prod
```
Now that you have two stacks, you can see which one is active by using the `pulumi stack ls` command
and looking to see which one has an asterisk next to the stack name. To change to a different stack,
use `pulumi stack select <stack-name>`
```shell
➜  infra git:(main) ✗ pulumi stack select prod
➜  infra git:(main) ✗ pulumi stack ls
NAME   LAST UPDATE     RESOURCE COUNT  URL
dev    10 seconds ago  24              https://app.pulumi.com/<USER>/exampulumi/dev
prod*  5 days ago      22              https://app.pulumi.com/<USER>/exampulumi/prod
```
We'll continue working in the prod stack going forward. Open up your route_53.py file and update it
as follows:
```python
import pulumi_aws as aws

from config import env, service_name, domain_name, PROD

def get_hosted_zone() -> aws.route53.Zone:
    if env == PROD:
        zone = aws.route53.Zone(
            f"{service_name}-zone",
            comment="",
            name=domain_name,
        )
        aws.route53domains.RegisteredDomain(
            f"{service_name}-registered-domain",
            domain_name=domain_name,
            name_servers=[
                aws.route53domains.RegisteredDomainNameServerArgs(
                    name=zone.name_servers[0],
                ),
                aws.route53domains.RegisteredDomainNameServerArgs(
                    name=zone.name_servers[1],
                ),
                aws.route53domains.RegisteredDomainNameServerArgs(
                    name=zone.name_servers[2],
                ),
                aws.route53domains.RegisteredDomainNameServerArgs(
                    name=zone.name_servers[3],
                ),
            ],
        )
    else:
        zone = aws.route53.get_zone(name=domain_name)
    return zone

hosted_zone = get_hosted_zone()
```
For prod, we want to add the registered domain that we created via the AWS console and we want to
create a Hosted zone for that domain. We also grab the name servers from the hosted zone and use
that to populate the name servers for the registered domain so that entering your fancy url into
a browser will lead you to your AWS-hosted site - internet magic! ✨ In non-prod stacks/environments
we simply want to fetch the existing hosted zone as the domain is now managed by the prod stack
and the name servers are already set up for the hosted zone.  

Next, open up your `acm.py` file and add the following.
```python
import pulumi
import pulumi_aws as aws

from config import domain_name, env, prefix, PROD
from resources.route_53 import hosted_zone

# CloudFront is in us-east-1. So you must create the certificate in
# us-east-1 regardless of your default AWS region
us_east_1 = aws.Provider("us-east-1", region="us-east-1")

def create_certificate(hosted_zone_id: str) -> aws.acm.Certificate:
    cert_domain_name = domain_name if env == PROD else f"{env}.{domain_name}"
    certificate = aws.acm.Certificate(
        f"{prefix}-certificate",
        domain_name=cert_domain_name,
        validation_method="DNS",
        validation_options=[
            aws.acm.CertificateValidationOptionArgs(
                domain_name=cert_domain_name, validation_domain="exampulumi.com"
            ),
        ],
        # Must be in us-east-1 to be used by cloudfront
        opts=pulumi.ResourceOptions(provider=us_east_1),
    )
    cert_validation_cname = aws.route53.Record(
        f"{prefix}-cert-validation-cname",
        name=certificate.domain_validation_options[0].resource_record_name,
        records=[certificate.domain_validation_options[0].resource_record_value],
        ttl=60,
        type=certificate.domain_validation_options[0].resource_record_type,
        zone_id=hosted_zone_id,
    )
    aws.acm.CertificateValidation(
        f"{prefix}-cert-validation",
        certificate_arn=certificate.arn,
        validation_record_fqdns=[cert_validation_cname.fqdn],
        opts=pulumi.ResourceOptions(provider=us_east_1),
    )
    return certificate

cert = create_certificate(hosted_zone.id)
```
You'll notice we are importing the hosted zone created in the prior step. There is also an aws.Provider
resource for `us-east-1`. This is a peculiarity you must put in place to enable your certificate to be
accessed and used by CloudFront. This file creates a certificate for the domain name, creates a CNAME 
DNS record in Route53 to be used to validate the certificate. And then the CertificateValidation
actually initiates the certificate validation via DNS process. Using DNS validation is preferred
as it will auto-renew your certificate, and you will not have to wake up to a page in 3 months
because you forgot to renew a certificate. The certificate validation is usually fairly fast
compared to other DNS propagation things, but it is still slow and and sometimes it will cause your
CloudFront distribution's creation to fail if you attempt to create both at the same time.
So let's run pulumi up now and create these resources now. First, update your `__main__.py` file.
```python
# __main__.py
import pulumi

from config import service_name
from resources.route_53 import hosted_zone
from resources.acm import cert

# Add your exports here
pulumi.export('service name', service_name)
pulumi.export("hosted_zone_id", hosted_zone.id)
pulumi.export("certificate", cert.arn)
```
And run `pulumi up`
```shell
➜  infra git:(1-static-site) ✗ pulumi up
Previewing update (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/previews/<UUID>

     Type                                    Name                                   Plan
 +   pulumi:pulumi:Stack                     exampulumi-prod                        create
 +   ├─ pulumi:providers:aws                 us-east-1                              create
 +   ├─ aws:acm:Certificate                  prod-exampulumi-certificate            create
 +   ├─ aws:route53:Zone                     exampulumi-zone                        create
 +   ├─ aws:route53:Record                   prod-exampulumi-cert-validation-cname  create
 +   ├─ aws:route53domains:RegisteredDomain  exampulumi-registered-domain           create
 +   └─ aws:acm:CertificateValidation        prod-exampulumi-cert-validation        create

Outputs:
    certificate   : output<string>
    hosted_zone_id: output<string>
    service name  : "exampulumi"

Resources:
    + 7 to create

Do you want to perform this update?  [Use arrows to move, type to filter]
> yes
  no
  details

Do you want to perform this update? yes
Updating (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/updates/56

     Type                                    Name                                   Status
 +   pulumi:pulumi:Stack                     exampulumi-prod                        created (55s)
 +   ├─ pulumi:providers:aws                 us-east-1                              created (0.21s)
 +   ├─ aws:route53:Zone                     exampulumi-zone                        created (53s)
 +   ├─ aws:acm:Certificate                  prod-exampulumi-certificate            created (6s)
 +   ├─ aws:route53:Record                   prod-exampulumi-cert-validation-cname  created (40s)
 +   ├─ aws:route53domains:RegisteredDomain  exampulumi-registered-domain           created (54s)
 +   └─ aws:acm:CertificateValidation        prod-exampulumi-cert-validation        created (55s)

Outputs:
    certificate   : "arn:aws:acm:us-east-1:***:certificate/***"
    hosted_zone_id: "Z****"
    service name  : "exampulumi"

Resources:
    + 7 created

Duration: 2m33s
```
You should now exist on the internet--go to a DNS lookup site and check for your NS records!  

## S3 Buckets--static site files and storage for CloudFront logs
Now that you can be found on the internet, we are going to create two s3 buckets. The first
one is where we will upload the files that comprise your static site. The other one will be
the location for the logs from CloudFront. The CloudFront logs are saved in batches.
Real-time logging for CloudFront is possible to enable via Kinesis but is beyond the scope
of this article.  

For now, we are just going to create the bucket. We'll add the actual static site, the code
to upload those files, and the code to use the logs bucket in later steps. As of April 2023,
AWS has updated the default settings on S3 buckets so that they default to disabling public
access and that also disables the use of ACLs by default. This added a bit of complexity
and I am not certain if the settings below are overly permissive but I am fairly certain
that the buckets and their contents are not public. They are only going to be accessible
via CloudFront once we set that up. However, the contents in your static bucket should not
contain anything sensitive as that is going to be loaded into users' browsers anyway since
it's your html, css, js and assorted media files. Add the following code to your `s3.py` file:
```python
import mimetypes
import os

from pulumi import FileAsset, ResourceOptions
import pulumi_aws as aws

from config import prefix, static_site_path

# Much of this file was taken from pulumi's static site example:
# https://github.com/pulumi/examples/tree/master/aws-py-static-website

def create_static_bucket() -> aws.s3.Bucket:
    bucket = aws.s3.Bucket(
        f"{prefix}-static-bucket",
        # You must set the ACL to something - private seems to work
        acl="private",
        bucket=f"{prefix}-bucket",
        lifecycle_rules=[
            aws.s3.BucketLifecycleRuleArgs(
                enabled=True,
                noncurrent_version_expiration=aws.s3.BucketLifecycleRuleNoncurrentVersionExpirationArgs(
                    days=7,
                ),
            )
        ],
        server_side_encryption_configuration=aws.s3.BucketServerSideEncryptionConfigurationArgs(
            rule=aws.s3.BucketServerSideEncryptionConfigurationRuleArgs(
                apply_server_side_encryption_by_default=aws.s3.BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs(
                    sse_algorithm="AES256",
                ),
                bucket_key_enabled=True,
            ),
        ),
        versioning=aws.s3.BucketVersioningArgs(
            enabled=True,
        ),
    )
    # This seems to allow us to upload files and access them via CloudFront
    aws.s3.BucketOwnershipControls(
        f"{prefix}-static-bucket-ownership-controls",
        bucket=bucket.id,
        rule=aws.s3.BucketOwnershipControlsRuleArgs(
            object_ownership="ObjectWriter",
        ),
    )
    # This alters the new default disabling of public access for new s3 buckets
    aws.s3.BucketPublicAccessBlock(
        f"{prefix}-static-bucket-public-access-block",
        bucket=bucket.id,
        block_public_acls=False,
        block_public_policy=False,
        ignore_public_acls=False,
        restrict_public_buckets=False,
    )
    return bucket

def create_cloudfront_log_bucket() -> aws.s3.BucketV2:
    current_user = aws.s3.get_canonical_user_id()
    log_delivery_user = aws.cloudfront.get_log_delivery_canonical_user_id()

    logs_bucket = aws.s3.BucketV2(
        f"{prefix}-cf-logs-bucket", bucket=f"{prefix}-cf-logs-bucket"
    )
    # Again this seems to be part of what is needed to enable logs to
    # be saved to the bucket
    aws.s3.BucketOwnershipControls(
        f"{prefix}-cf-logs-bucket-ownership-controls",
        bucket=logs_bucket.id,
        rule=aws.s3.BucketOwnershipControlsRuleArgs(
            object_ownership="ObjectWriter",
        ),
    )
    # Seem to need this but maybe not?
    aws.s3.BucketPublicAccessBlock(
        f"{prefix}-cf-logs-bucket-public-access-block",
        bucket=logs_bucket.id,
        block_public_acls=False,
        block_public_policy=False,
        ignore_public_acls=False,
        restrict_public_buckets=False,
    )
    # This is needed to give the permissions for the log writer to be able
    # to write logs to the bucket.
    aws.s3.BucketAclV2(
        f"{prefix}-cf-logs-bucket-acl-v2",
        bucket=logs_bucket.id,
        access_control_policy=aws.s3.BucketAclV2AccessControlPolicyArgs(
            grants=[
                aws.s3.BucketAclV2AccessControlPolicyGrantArgs(
                    grantee=aws.s3.BucketAclV2AccessControlPolicyGrantGranteeArgs(
                        id=current_user.id,
                        type="CanonicalUser",
                    ),
                    permission="FULL_CONTROL",
                ),
                aws.s3.BucketAclV2AccessControlPolicyGrantArgs(
                    grantee=aws.s3.BucketAclV2AccessControlPolicyGrantGranteeArgs(
                        id=log_delivery_user.id,
                        type="CanonicalUser",
                    ),
                    permission="FULL_CONTROL",
                ),
            ],
            owner=aws.s3.BucketAclV2AccessControlPolicyOwnerArgs(
                id=current_user.id,
            ),
        ),
    )
    return logs_bucket

static_bucket = create_static_bucket()
cf_log_bucket = create_cloudfront_log_bucket()
```
Now add those buckets to the `__main__.py` file.
```python
import pulumi

from config import service_name
from resources.route_53 import hosted_zone
from resources.acm import cert
from resources.s3 import cf_log_bucket, static_bucket

# Add your exports here
pulumi.export("service name", service_name)
pulumi.export("hosted_zone_id", hosted_zone.id)
pulumi.export("certificate", cert.arn)
pulumi.export("static_bucket_arn", static_bucket.arn)
pulumi.export("cf_log_bucket_arn", cf_log_bucket.arn)
```
And let's run `pulumi up` and create a couple buckets.
```shell
➜  infra git:(1-static-site) ✗ pulumi up
Previewing update (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/previews/<UUID>

     Type                               Name                                                Plan
     pulumi:pulumi:Stack                exampulumi-prod
 +   ├─ aws:s3:Bucket                   prod-exampulumi-static-bucket                       create
 +   ├─ aws:s3:BucketOwnershipControls  prod-exampulumi-static-bucket-ownership-controls    create
 +   ├─ aws:s3:BucketPublicAccessBlock  prod-exampulumi-static-bucket-public-access-block   create
 +   ├─ aws:s3:BucketV2                 prod-exampulumi-cf-logs-bucket                      create
 +   ├─ aws:s3:BucketOwnershipControls  prod-exampulumi-cf-logs-bucket-ownership-controls   create
 +   ├─ aws:s3:BucketPublicAccessBlock  prod-exampulumi-cf-logs-bucket-public-access-block  create
 +   └─ aws:s3:BucketAclV2              prod-exampulumi-cf-logs-bucket-acl-v2               create

Outputs:
  + cf_log_bucket_arn: output<string>
  + static_bucket_arn: output<string>

Resources:
    + 7 to create
    7 unchanged

Do you want to perform this update?  [Use arrows to move, type to filter]
> yes
  no
  details

Updating (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/updates/70

     Type                               Name                                                Status
     pulumi:pulumi:Stack                exampulumi-prod
 +   ├─ aws:s3:Bucket                   prod-exampulumi-static-bucket                       created (3s)
 +   ├─ aws:s3:BucketV2                 prod-exampulumi-cf-logs-bucket                      created (2s)
 +   ├─ aws:s3:BucketOwnershipControls  prod-exampulumi-static-bucket-ownership-controls    created (0.99s)
 +   ├─ aws:s3:BucketPublicAccessBlock  prod-exampulumi-static-bucket-public-access-block   created (0.99s)
 +   ├─ aws:s3:BucketOwnershipControls  prod-exampulumi-cf-logs-bucket-ownership-controls   created (1s)
 +   ├─ aws:s3:BucketPublicAccessBlock  prod-exampulumi-cf-logs-bucket-public-access-block  created (1s)
 +   └─ aws:s3:BucketAclV2              prod-exampulumi-cf-logs-bucket-acl-v2               created (1s)

Outputs:
    certificate      : "arn:aws:acm:us-east-1:***:certificate/*****"
  + cf_log_bucket_arn: "arn:aws:s3:::prod-exampulumi-cf-logs-bucket"
    hosted_zone_id   : "Z********"
    service name     : "exampulumi"
  + static_bucket_arn: "arn:aws:s3:::prod-exampulumi-static-bucket"

Resources:
    + 7 created
    7 unchanged

Duration: 9s
```
## Add Static Site
There are oodles of blogs on creating a basic react app. I used the TypeScript variant of
Create React App and then I added react-router so that I could have a home page at the
root, https://exampulumi.com and another page at https://exampulumi.com/other-page.
You can also just copy all of my frontend files from the `ui` directory at:
[https://github.com/dmegbert/exampulumi](https://github.com/dmegbert/exampulumi)
and `run yarn && yarn build`. Once you have your static site created and a build you should
have a project structure something similar to the following:
```shell
.
├── LICENSE
├── README.md
├── infra
│   ├── Pulumi.dev.yaml
│   ├── Pulumi.prod.yaml
│   ├── Pulumi.yaml
│   ├── __main__.py
│   ├── config.py
│   ├── requirements.txt
│   └── resources
│       ├── __init__.py
│       ├── __pycache__
│       ├── acm.py
│       ├── cloud_front.py
│       ├── route_53.py
│       └── s3.py
└── ui
    ├── README.md
    ├── build
    │   ├── asset-manifest.json
    │   ├── favicon.ico
    │   ├── index.html
    │   └── static
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   └── index.html
    ├── src
    │   └── index.tsx
    ├── tsconfig.json
    └── yarn.lock
```
If you recall when we added the `config.py` file, we added a constant of `static_site_path = "../ui/build".`
As you can see above, the build files are in ui/build directory. If your static artifacts are elsewhere,
just update that constant value.  

The next code was copied and only mildly tweaked from Pulumi's example for setting up a static site--thanks
friends! I put this code in the s3.py file after the buckets. These are a couple handy functions that crawl
your build directory recursively, detect the file type, convert it to a s3 bucket object, and toss it into
the bucket for you. And with a pulumi up your static site will be up in the cloud and nearly accessible
from the internets (one more step--hang in there, kitty!)
```python
import mimetypes
import os

def get_web_contents_root_path() -> str:
    return os.path.join(os.getcwd(), static_site_path)

def crawl_static_dir(static_dir, converter_function, bucket) -> None:
    for file in os.listdir(static_dir):
        filepath = os.path.join(static_dir, file)

        if os.path.isdir(filepath):
            crawl_static_dir(filepath, converter_function, bucket)
        elif os.path.isfile(filepath):
            converter_function(filepath, bucket=bucket)

def bucket_object_converter(filepath, bucket) -> None:
    """
    Takes a file path and returns a bucket object managed by Pulumi
    """
    web_contents_root_path = get_web_contents_root_path()
    relative_path = filepath.replace(web_contents_root_path + "/", "")
    # Determine the mimetype using the `mimetypes` module.
    mime_type, _ = mimetypes.guess_type(filepath)
    aws.s3.BucketObject(
        relative_path,
        key=relative_path,
        acl="public-read",
        bucket=bucket.id,
        content_type=mime_type,
        source=FileAsset(filepath),
        opts=ResourceOptions(parent=bucket),
    )

static_web_contents_root_path = get_web_contents_root_path()
crawl_static_dir(static_web_contents_root_path, bucket_object_converter, static_bucket)
```
And run `pulumi up`
```shell
➜  infra git:(1-static-site) ✗ pulumi up
Previewing update (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/previews/<UUID>

     Type                       Name                                    Plan
     pulumi:pulumi:Stack        exampulumi-prod
     └─ aws:s3:Bucket           prod-exampulumi-static-bucket
 +      ├─ aws:s3:BucketObject  index.html                              create
 +      ├─ aws:s3:BucketObject  favicon.ico                             create
 +      ├─ aws:s3:BucketObject  static/js/main.1a088b93.js.LICENSE.txt  create
 +      ├─ aws:s3:BucketObject  asset-manifest.json                     create
 +      ├─ aws:s3:BucketObject  static/js/main.1a088b93.js              create
 +      └─ aws:s3:BucketObject  static/js/main.1a088b93.js.map          create

Resources:
    + 6 to create
    14 unchanged

Do you want to perform this update?  [Use arrows to move, type to filter]
> yes
  no
  details

Updating (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/updates/72

     Type                       Name                                    Status
     pulumi:pulumi:Stack        exampulumi-prod
     └─ aws:s3:Bucket           prod-exampulumi-static-bucket
 +      ├─ aws:s3:BucketObject  favicon.ico                             created (1s)
 +      ├─ aws:s3:BucketObject  index.html                              created (1s)
 +      ├─ aws:s3:BucketObject  asset-manifest.json                     created (1s)
 +      ├─ aws:s3:BucketObject  static/js/main.1a088b93.js.LICENSE.txt  created (1s)
 +      ├─ aws:s3:BucketObject  static/js/main.1a088b93.js              created (2s)
 +      └─ aws:s3:BucketObject  static/js/main.1a088b93.js.map          created (4s)

Outputs:
    certificate      : "arn:aws:acm:us-east-1:282753966079:certificate/9532ed59-da33-4377-b9d5-f5b1ce375ca4"
    cf_log_bucket_arn: "arn:aws:s3:::prod-exampulumi-cf-logs-bucket"
    hosted_zone_id   : "Z0503047AAST4999UASG"
    service name     : "exampulumi"
    static_bucket_arn: "arn:aws:s3:::prod-exampulumi-static-bucket"

Resources:
    + 6 created
    14 unchanged

Duration: 7s
```
## Using CloudFront as your CDN
I find CloudFront to be an incredibly powerful and flexible tool. It also seems to be really
poorly documented and hard to understand. Or perhaps that's just more due to my ignorance.
Regardless, after many deep dives into blogs, AWS documentation, and a lot of trial and
error I've used CloudFront for a number of use cases with some degree of success. But I
really have barely scratched the surface. You can use it to to decrease latency, cache
common requests, run lambda functions around the world at the CDN locations, block
traffic based on all sorts of rules using WAFs, geography, only allow folks on your
VPN to access the site, etc. Anyway, my point is that its powerful and worth learning despite
the unfriendly and steep learning curve.  

We will be using it as the way to point traffic from Route53 to our S3 static bucket. And
we'll log those requests to the cf-logs S3 bucket. One reason to use CloudFront is to enable
React Router's client-side routing to play nicely with our S3 bucket. If you attempt to just
use an S3 bucket's static site hosting feature to deploy a React app that uses React Router,
you will encounter a bucket full of sadness. As you're going to get a really ugly xml S3
error page when you go to any page other than your root / page.

![S3 error is shown when going to exampulumi.com/other](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/reactRouterError.png "React Router Error")

With CloudFront, you can specify custom error responses. So we will have 403 and 404 responses
direct back to the /index.html page and change the response code to 200. This will enable
react router to implement its client side routing and error handling for 404s.

![Page displays properly when going to exampulumi.com/other](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/reactRouterSuccess.png "React Router Success")

Add this to the `cloud_front.py` file. There is a lot going on in this file. From the top--you'll
notice that we are importing both of our S3 buckets, our hosted zone, and our certificate
from the other resource files as CloudFront uses or connects all the things.  

The first resource we create within the `create_cloudfront_distribution` function is an origin
access control. This enables CloudFront to access your S3 static bucket and make your site
reachable on the web.  

The next resource is the actual distribution. In it we set the aliases
to our domain name (exampulumi.com for prod and dev.exampulumi.com for dev). Then we add the
custom error response handling so that our infrastructure will play nicely with react router
as I mentioned earlier. I set caching to 0 TTL (time to live) throughout this example effectively
disabling caching. If you end up using caching, you'll also need to do something to invalidate
the cache upon uploading new static site files.

The default_cache_behavior settings of note are the viewer_protocol_policy of redirect to
https--we are using a certificate so it's best practice to simply redirect any accidental
http://<your-site>.com requests to https://<your-site>.com to keep things nice and secure.
And, again, you'll see that I'm effectively disabling caching with 0 TTL for all of those
settings. Your users browsers will still cache your files. CloudFront just won't be caching
and will retrieve your files from the S3 bucket when a request is received.  

![Caching is still happening on your local machine](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/localCaching.png "Local Caching")

The `default_root_object` points to the index.html file of your static site. You make the
CloudFront distribution active by setting `enabled` to true so that it will route traffic to your S3 bucket.  

In the origins setting is where you connect CloudFront to your static S3 bucket through the Origin Access
Control. The domain_name is referring to the domain name that every S3 bucket is automatically assigned.
It is not your site's domain name so that is where we use our bucket resource to get that domain name
programmatically. Then you have the origin id that is the arbitrary string value you set up earlier in
the function. And then there is the `origin_access_control_id` that enables CloudFront
to access and serve the contents in your static S3 bucket.  

The restrictions section is bare bones but you can add a lot of control there. And the final step is
to attach the certificate so our site will be served over https and you will see the reassuring
little padlock next to your url instead of scary warning messages.

```python
import pulumi_aws as aws

from config import env, prefix, domain_name, PROD
from resources.acm import cert
from resources.route_53 import hosted_zone
from resources.s3 import cf_log_bucket, static_bucket

alias = domain_name if env == PROD else f"{env}.{domain_name}"

def create_cloudfront_distribution(
    certificate: aws.acm.Certificate, bucket: aws.s3.Bucket
) -> aws.cloudfront.Distribution:
    # This origin id can be any arbitrary string value
    s3_origin_id = f"{prefix}-s3-origin-id"
    origin_access_control = aws.cloudfront.OriginAccessControl(
        f"{prefix}-origin-access-control",
        description="S3 Bucket Policy",
        origin_access_control_origin_type="s3",
        signing_behavior="always",
        signing_protocol="sigv4",
    )

    return aws.cloudfront.Distribution(
        f"{prefix}-distribution",
        aliases=[alias],
        custom_error_responses=[
            aws.cloudfront.DistributionCustomErrorResponseArgs(
                error_code=404,
                response_code=200,
                error_caching_min_ttl=0,
                response_page_path="/index.html",
            ),
            aws.cloudfront.DistributionCustomErrorResponseArgs(
                error_code=403,
                response_code=200,
                error_caching_min_ttl=0,
                response_page_path="/index.html",
            ),
        ],
        default_cache_behavior=aws.cloudfront.DistributionDefaultCacheBehaviorArgs(
            allowed_methods=[
                "GET",
                "HEAD",
            ],
            cached_methods=[
                "GET",
                "HEAD",
            ],
            target_origin_id=s3_origin_id,
            forwarded_values=aws.cloudfront.DistributionDefaultCacheBehaviorForwardedValuesArgs(
                query_string=False,
                cookies=aws.cloudfront.DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs(
                    forward="none",
                ),
            ),
            viewer_protocol_policy="redirect-to-https",
            min_ttl=0,
            default_ttl=0,
            max_ttl=0,
        ),
        default_root_object="index.html",
        enabled=True,
        is_ipv6_enabled=True,
        logging_config=aws.cloudfront.DistributionLoggingConfigArgs(
            include_cookies=False,
            bucket=cf_log_bucket.bucket_domain_name,
        ),
        origins=[
            aws.cloudfront.DistributionOriginArgs(
                domain_name=bucket.bucket_domain_name,
                origin_id=s3_origin_id,
                origin_access_control_id=origin_access_control.id,
            )
        ],
        restrictions=aws.cloudfront.DistributionRestrictionsArgs(
            geo_restriction=aws.cloudfront.DistributionRestrictionsGeoRestrictionArgs(
                restriction_type="none",
            ),
        ),
        viewer_certificate=aws.cloudfront.DistributionViewerCertificateArgs(
            acm_certificate_arn=certificate.arn,
            minimum_protocol_version="TLSv1.2_2021",
            ssl_support_method="sni-only",
        ),
    )

cf_distro = create_cloudfront_distribution(certificate=cert, bucket=static_bucket)

def create_dns_records(
    distribution: aws.cloudfront.Distribution,
) -> (aws.route53.Record, aws.route53.Record):
    alias_a_record = aws.route53.Record(
        f"{env}-a-record",
        name=alias,
        zone_id=hosted_zone.id,
        type="A",
        aliases=[
            aws.route53.RecordAliasArgs(
                name=distribution.domain_name,
                zone_id=distribution.hosted_zone_id,
                evaluate_target_health=True,
            )
        ],
    )

    alias_aaaa_record = aws.route53.Record(
        f"{env}-aaaa-record",
        name=alias,
        zone_id=hosted_zone.id,
        type="AAAA",
        aliases=[
            aws.route53.RecordAliasArgs(
                name=distribution.domain_name,
                zone_id=distribution.hosted_zone_id,
                evaluate_target_health=True,
            )
        ],
    )
    return alias_a_record, alias_aaaa_record

a_record, aaaa_record = create_dns_records(distribution=cf_distro)
```
And update `__main__.py`

```python
import pulumi

from config import service_name
from resources.route_53 import hosted_zone
from resources.acm import cert
from resources.s3 import cf_log_bucket, static_bucket
from resources.cloud_front import cf_distro, a_record, aaaa_record

# Add your exports here
pulumi.export("service name", service_name)
pulumi.export("hosted_zone_id", hosted_zone.id)
pulumi.export("certificate", cert.arn)
pulumi.export("static_bucket_arn", static_bucket.arn)
pulumi.export("cf_log_bucket_arn", cf_log_bucket.arn)
pulumi.export("cloudfront_distro_id", cf_distro.id)
pulumi.export("a_record", a_record.name)
pulumi.export("aaaa_record", aaaa_record.name)
```
Run `pulumi up`. CloudFront distributions take a few minutes to be created and deployed. So it's
a good time to go get a coffee.
```shell
➜  infra git:(1-static-site) ✗ pulumi up
Previewing update (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/previews/<UUID>

     Type                                   Name                                   Plan
     pulumi:pulumi:Stack                    exampulumi-prod
 +   ├─ aws:cloudfront:OriginAccessControl  prod-exampulumi-origin-access-control  create
 +   ├─ aws:cloudfront:Distribution         prod-exampulumi-distribution           create
 +   ├─ aws:route53:Record                  prod-a-record                          create
 +   └─ aws:route53:Record                  prod-aaaa-record                       create

Outputs:
  + a_record            : "exampulumi.com"
  + aaaa_record         : "exampulumi.com"
  + cloudfront_distro_id: output<string>

Resources:
    + 4 to create
    20 unchanged

Do you want to perform this update?  [Use arrows to move, type to filter]
> yes
  no
  details

Do you want to perform this update? yes
Updating (prod)

View in Browser (Ctrl+O): https://app.pulumi.com/<USER>/exampulumi/prod/updates/79

     Type                                   Name                                   Status
     pulumi:pulumi:Stack                    exampulumi-prod
 +   ├─ aws:cloudfront:OriginAccessControl  prod-exampulumi-origin-access-control  created (0.58s)
 +   ├─ aws:cloudfront:Distribution         prod-exampulumi-distribution           created (189s)
 +   ├─ aws:route53:Record                  prod-a-record                          created (34s)
 +   └─ aws:route53:Record                  prod-aaaa-record                       created (43s)

Outputs:
  + a_record            : "exampulumi.com"
  + aaaa_record         : "exampulumi.com"
    certificate         : "arn:aws:acm:us-east-1:**:certificate/***"
    cf_log_bucket_arn   : "arn:aws:s3:::prod-exampulumi-cf-logs-bucket"
  + cloudfront_distro_id: "E***"
    hosted_zone_id      : "Z***"
    service name        : "exampulumi"
    static_bucket_arn   : "arn:aws:s3:::prod-exampulumi-static-bucket"

Resources:
    + 4 created
    20 unchanged

Duration: 3m56s
```
## Your Site is Live!!
![A website!](https://raw.githubusercontent.com/dmegbert/exampulumi/main/blog/img/homePage.png "Live Website")
